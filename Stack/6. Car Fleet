
public class Solution {
    public int carFleet(int target, int[] position, int[] speed) {
        int n = position.length;
        double[][] cars = new double[n][2];
        
        for (int i = 0; i < n; i++) {
            cars[i][0] = position[i];
            cars[i][1] = (double)(target - position[i]) / speed[i];
        }
        
        Arrays.sort(cars, (a, b) -> Double.compare(b[0], a[0]));
        
        int count = 0;
        double prevTime = 0;
        for (double[] car : cars) {
            if (car[1] > prevTime) {
                count++;
                prevTime = car[1];
            }
        }
        
        return count;
    }
}


/*

ğŸ” Understanding the Problem
We have cars starting from different positions, each moving at its own speed towards a target point.
The rules are:

A car cannot overtake another car.
If a faster car reaches a slower car before the target, they merge and move together at the slower carâ€™s speed.
Our goal is to count the number of separate fleets that reach the target.

ğŸ§  Thought Process to Solve
To figure this out, we need to determine:

How long each car takes to reach the target.
Whether cars will merge or stay separate.
We will do this step by step:

ğŸ› ï¸ Step 1: Calculate Time to Reach Target
Each carâ€™s time to reach the target is calculated as:

time = targetâˆ’position[ğ‘–] / speed[ğ‘–]â€‹
 
This tells us when a car would reach the target if it didnâ€™t merge with another car.

ğŸ“Œ Step 2: Sort Cars by Position
We sort cars from farthest to closest to the target.

This way, we process the cars in the order they move and can check if a car catches up to another.
If a slower car is ahead of a faster one, they will form a fleet and move together.

ğŸ”„ Step 3: Process Cars One by One
Now, we loop through the cars (from farthest to closest):

If a carâ€™s time is greater than the one before it â†’ it forms a new fleet.
Otherwise, it joins the previous fleet.

âœ… Final Answer
The number of times a car does not catch up to the previous one tells us the number of fleets.

ğŸ“ Summary
Calculate time for each car to reach the target.
Sort cars by position from farthest to closest.
Loop through cars:
If a carâ€™s time is more than the previous one, it forms a new fleet.
Otherwise, it joins the previous fleet.
Return the number of fleets.


*/
