
public class Solution {
    public int carFleet(int target, int[] position, int[] speed) {
        int n = position.length;
        double[][] cars = new double[n][2];
        
        for (int i = 0; i < n; i++) {
            cars[i][0] = position[i];
            cars[i][1] = (double)(target - position[i]) / speed[i];
        }
        
        Arrays.sort(cars, (a, b) -> Double.compare(b[0], a[0]));
        
        int count = 0;
        double prevTime = 0;
        for (double[] car : cars) {
            if (car[1] > prevTime) {
                count++;
                prevTime = car[1];
            }
        }
        
        return count;
    }
}


/*

🔍 Understanding the Problem
We have cars starting from different positions, each moving at its own speed towards a target point.
The rules are:

A car cannot overtake another car.
If a faster car reaches a slower car before the target, they merge and move together at the slower car’s speed.
Our goal is to count the number of separate fleets that reach the target.

🧠 Thought Process to Solve
To figure this out, we need to determine:

How long each car takes to reach the target.
Whether cars will merge or stay separate.
We will do this step by step:

🛠️ Step 1: Calculate Time to Reach Target
Each car’s time to reach the target is calculated as:

time = target−position[𝑖] / speed[𝑖]​
 
This tells us when a car would reach the target if it didn’t merge with another car.

📌 Step 2: Sort Cars by Position
We sort cars from farthest to closest to the target.

This way, we process the cars in the order they move and can check if a car catches up to another.
If a slower car is ahead of a faster one, they will form a fleet and move together.

🔄 Step 3: Process Cars One by One
Now, we loop through the cars (from farthest to closest):

If a car’s time is greater than the one before it → it forms a new fleet.
Otherwise, it joins the previous fleet.

✅ Final Answer
The number of times a car does not catch up to the previous one tells us the number of fleets.

📝 Summary
Calculate time for each car to reach the target.
Sort cars by position from farthest to closest.
Loop through cars:
If a car’s time is more than the previous one, it forms a new fleet.
Otherwise, it joins the previous fleet.
Return the number of fleets.


*/
